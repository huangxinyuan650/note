### 最小生成树(Prim、Kruskal)
```python
# _*_ coding:utf-8_*_
# Author:   Ace Huang
# Time: 2020/6/10 23:55
# File: MiniTree.py

class MiniTreeCal(object):


    def prim_cal(self):
        """
        由小到大增加节点集合，增加方式为逐个从未知节点中增加与已知集合中节点最近的节点
        :return:
        """
        pass

    def kruskal_cal(self):
        """
        由小到大增加边，只要所有已知边与新增的边不产生回路即可
        :return:
        """
```
### 哈夫曼树(Huffman、最优二叉树)
带权路径最短的二叉树。（常用于编码）
- 由小到大取最小的两个节点变成左右子树，并将合成的树的父节点变成左右子树带权和加入到待处理节点中参与新的排序取数，最终生成的树即为Huffman树

### 布隆过滤器
由一个很长的bit数组和一系列哈希函数组成，用来判断某个元素是否在一个较大的集合中（若判断不存在则该元素肯定不存在大集合中，若判断存在但还存在误判的情况，但概率非常小）
#### 插入逻辑
当一个元素要加入到布隆过滤器时，先由k个hash函数计算得到k个hash值，根据hash值将bit数组中所有对应的位置置为1
#### 存在判断逻辑
判断一个元素是否存在布隆过滤器时，先由k个hash函数计算得到k个hash值，判断bit数组中k个hash值对应的位置的值是否为1，若全为1则判断元素存在，若有一个不为1则判断元素不存在
#### 误差说明
若一个元素不在布隆过滤器中，但其他已存在的元素通过hash函数计算得到的结果和该元素hash函数计算的结果相同并将bit数组中对应的值置为1了，这样判断存在与否时对应位置的值为1就可能出现误判存在，但此种情况的发生是该元素对应的k个位置都有其他已存在的元素的hash值冲突了，概率较小
#### 计算说明
bit数组大小为m，样本数为n，误差概率为p，哈希函数个数
- 前提条：样本数n为100亿、p为0.01%
- 1、m = -n*lnp/(ln2)^2 => m = 19.19n => m约为2000亿
- 2、k = ln2 * m/n => k约为14，即14个哈希函数
- 3、真实失误率 p = (1 - e**(-nk/m))**k => p约为0.006%

